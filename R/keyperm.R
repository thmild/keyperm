#' Calculate the permutation distribution for a keyness measure
#' 
#' Calculate the permutation distributions of a given keyness measure for each term by 
#' shuffeling the copus labels. Number of documents per corpus is kept constant.    
#' 
#' Currently, the following types of scores are supported:
#' \describe{
#'     \item{\code{llr}}{The log-likelihood ratio}
#'     \item{\code{chisq}}{The Chi-Square-Statistic}
#'     \item{\code{diff}}{Difference of relative frequencies}
#'     \item{\code{logratio}}{Binary logarithm of the ratio of the relative frequencies, possibly using a laplace correction to avoid infinite values.}
#'  }
#' 
#'  \code{llr} and \code{chisq} are the test-statistics for a two-by-two contingency table. Both measure deviations from equal proportions but do not indicate the direction. For \code{llr}, the correct version using terms for all four fields of the table is used, not the version using only two terms that is sometimes used in corpus linguistics.
#'
#'  \code{diff} and \code{logratio} are measures of the effect size, but using the permutation approach implemented here a p-value can be calculated as well. Both indicate the direction of the effect, and can be used for one- or two-sided tests. 
#'
#'  \code{logratio} is based on a ratio of ratios and would be infinite when a term does not occur in either of the two corpora, irrespective of number of occurences in the other corpus. Hence, we use a laplace correction adding a (not neccesarily integer) number \eqn{k} of ficticious occurences to both corpora: 
#'  \deqn{logratio = log2( ((n_A + k) / (N_A + k)) / ((n_B + k) / (N_B + k)) }
#'  where \eqn{n_A} and \eqn{n_B} are the number of occurences of the term of interest in Corpora A and B 
#'  and \eqn{N_A} and \eqn{N_B} are the total numbers of tokens in A and B. 
#'  Setting \eqn{k} to zero corresponds to the usual logratio (which may be 
#'  infinite). \eqn{k} is given by the \code{laplace} argument and 
#'  defaults to one, meaning one ficticious occurence is added to 
#'  either corpus. Doing so prevents infinite values but has little 
#'  effect when the number of occurences is large.  
#'  
#' @param ifl Indexed frequency list as generated by \code{create_ifl()}.
#' @param observed The vector of observed values of the keyness scores as generarted by \code{keyness_scores()}
#' @param type The type of keyness measure. One of \code{llr}, \code{chisq}, \code{diff} or \code{logratio}. See details. 
#' @param laplace Parameter of laplace correction. Only relevant for \code{type = "logratio"}. See details. 
#' @param output The type of output. \code{output = 1} a matrix with all generated scores is returned,
#'     for \code{output = 2} a matrix with three columns counting the number of permutations for which the 
#'     score is strictly smaller than, equal to or strictly larger than the observed value. 
#' @param nperm The number of permutations to generate.         
#' @return A numeric matrix with number of rows equal to the number of terms. The columns contain either all permutation values
#'     of the keyness score (\code{output = 1}) or the number of permutations for which the 
#'     score is strictly smaller than, equal to or strictly larger than the observed value (\code{output = 2}).  
keyperm <- function(ifl,
                    observed,
                    type = "llr",
                    laplace = 1.0,
                    output = 2,
                    nperm) {
  scoretype <- switch(type,
                      llr = 1,
                      chisq = 2,
                      diff = 3,
                      logratio = 4)

  out <-  genPerm(ind = ifl$corp_A,
                  start_vek = ifl$index$start,
                  nterm = ifl$index$nterms,
                  freqs = ifl$freqlist$freq,
                  termlist = ifl$freqlist$term,
                  rowsums = ifl$rowsums,
                  colsums = ifl$colsums,
                  ntotal = ifl$ntotal,
                  nperm = nperm,
                  output = output,
                  scoretype = scoretype,
                  observed = observed,
                  laplace = laplace
  )
  out
}

